# 堆

堆分为最大堆和最小堆。（以下示例用最小堆）

有两个特征：

1. 任何节点的值都小于等于其子节点的值。
2. 是完全二叉树。



# 优先级队列

利用最大堆和最小堆实现， 初始化为空。

主要操作是：

1. 插入：insert
2. 提取：extract



# 堆排序堆

堆排序不需要辅助数组，原数组中前面为建立好的堆，后面为无序数据。把无序数据一个一个加入到堆中，进行调整即可。



# 以上内容涉及的相关操作

通常的C实现中，数组从1开始，第0不用。

* 调整为最大堆/最小堆：（初始化的时候无序，所以需要先调整）
  * 从[n]的父节点[n/2]开始调整，一直到根节点， cur=n/2；
  * 把左、右、父中最大/最小（取决与调整为最大堆或最小堆）的节点放父节点位置。
  * cur--；（一直到cur==1，为根节点）


* 向上调整：siftup（以下两个向上向下的调整是针对堆变动时候的）

  1. 如果当前节点是根节点（下标1）， 则退出调整。
  2. 当前节点和父节点比较，如果小于则交换。（注意说的是最小堆）

* 向下调整：siftdown

  * 基本思路：当前节点为父节点，左右父取最小的放父节点位置。

  1. 判断当前节点(i)的左右子节点是否存在；（当前节点为变动了的节点）
  2. 用一个变量(a)指向左右节点中小的那个；
  3. 如果[a]<[i]，则交换。

* 插入：insert
  1. 把要插入的节点（i）放到堆的最后；
  2. 进行向上调整。

* 提取：extract
  1. 保存[1]（第1个就是目标）
  2. 把[1]和[n]交换。
  3. 从[1]（根节点开始）向下调整。



> siftup一般用在insert，因为insert一般先把数据放到n的位置（最后一个位置），然后再用siftup调整。
>
> siftdown一般用在extract， 取走一般是[1], 把[n]和[1]交换，然后再siftdown调整。